<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Docker Networking, Entry Points, and more. | Ahmed Ayman</title><meta name=keywords content><meta name=description content="Diving with the Whale - Docker Day IV - Docker Networking, Entry Points, and more. Docker Networking How can we let two or more containers talking to each other ? through docker containers!
Networking in containers is controlling who can talk to who including all the running containers, and the local-host.
  Docker Network Drivers
Several drivers exist by default in docker, and provide core networking functionality
  Bridge Network"><meta name=author content="Ahmed Ayman"><link rel=canonical href=https://a7medayman6.github.io/blog/devops/diving-with-the-whale-docker-series/day-iv/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.min.d9015f4cb657fd3539b79b29ffbd11de4175ccd105ad7591beffaadfafb48488.css integrity="sha256-2QFfTLZX/TU5t5sp/70R3kF1zNEFrXWRvv+q36+0hIg=" rel="preload stylesheet" as=style><link rel=preload href=profile-pic.jpeg as=image><script defer crossorigin=anonymous src=/assets/js/highlight.min.27cd435cc9ed6abb4b496581b151804f79f366c412620272bb94e2f5f598ebcc.js integrity="sha256-J81DXMntartLSWWBsVGAT3nzZsQSYgJyu5Ti9fWY68w=" onload=hljs.initHighlightingOnLoad();></script><link rel=icon href=https://a7medayman6.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://a7medayman6.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://a7medayman6.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://a7medayman6.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://a7medayman6.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.68.3"><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');ga('create','UA-123-45','auto');ga('send','pageview');}</script><meta property="og:title" content="Docker Networking, Entry Points, and more."><meta property="og:description" content="Diving with the Whale - Docker Day IV - Docker Networking, Entry Points, and more. Docker Networking How can we let two or more containers talking to each other ? through docker containers!
Networking in containers is controlling who can talk to who including all the running containers, and the local-host.
  Docker Network Drivers
Several drivers exist by default in docker, and provide core networking functionality
  Bridge Network"><meta property="og:type" content="article"><meta property="og:url" content="https://a7medayman6.github.io/blog/devops/diving-with-the-whale-docker-series/day-iv/"><meta property="og:image" content="https://a7medayman6.github.io/static/"><meta property="article:section" content="blog"><meta property="article:published_time" content="2021-07-28T01:16:57+02:00"><meta property="article:modified_time" content="2021-07-28T01:16:57+02:00"><meta property="og:site_name" content="Ahmed Ayman"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://a7medayman6.github.io/static/"><meta name=twitter:title content="Docker Networking, Entry Points, and more."><meta name=twitter:description content="Diving with the Whale - Docker Day IV - Docker Networking, Entry Points, and more. Docker Networking How can we let two or more containers talking to each other ? through docker containers!
Networking in containers is controlling who can talk to who including all the running containers, and the local-host.
  Docker Network Drivers
Several drivers exist by default in docker, and provide core networking functionality
  Bridge Network"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":4,"name":"Docker Networking, Entry Points, and more.","item":"https://a7medayman6.github.io/blog/devops/diving-with-the-whale-docker-series/day-iv/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Docker Networking, Entry Points, and more.","name":"Docker Networking, Entry Points, and more.","description":"Diving with the Whale - Docker Day IV - Docker Networking, Entry Points, and more. Docker Networking How can we let two or more containers talking to each other ? through docker containers!\nNetworking in containers is controlling who can talk to who including all the running containers, and the local-host.\n  Docker Network Drivers\nSeveral drivers exist by default in docker, and provide core networking functionality\n  Bridge Network","keywords":[],"articleBody":"Diving with the Whale - Docker Day IV - Docker Networking, Entry Points, and more. Docker Networking How can we let two or more containers talking to each other ? through docker containers!\nNetworking in containers is controlling who can talk to who including all the running containers, and the local-host.\n  Docker Network Drivers\nSeveral drivers exist by default in docker, and provide core networking functionality\n  Bridge Network\nThe default network driver. If you don’t specify a driver, this is the type of network you are creating. Bridge networks are usually used when your applications run in standalone containers that need to communicate.\nyou can also create your own user-defined bridge network and connect multiple container to it so they can contact with each other! - we’ll see how in the next section -\n A network bridge is a computer networking hardware device or a software device running within a host machine’s kernel. that creates a single, aggregate network from multiple communication networks or network segments. This function is called network bridging. Bridging is distinct from routing. Routing allows multiple networks to communicate independently and yet remain separate, whereas bridging connects two separate networks as if they were a single network. In the OSI model, bridging is performed in the data link layer (layer 2). If one or more segments of the bridged network are wireless, the device is known as a wireless bridge.\n  Bridging (networking) - Wikipedia   In terms of Docker, a bridge network uses a software bridge which allows containers connected to the same bridge network to communicate, while providing isolation from containers which are not connected to that bridge network. The Docker bridge driver automatically installs rules in the host machine so that containers on different bridge networks cannot communicate directly with each other.\n  Use bridge networks - Docker Docs    Host Network  For standalone containers, remove network isolation between the container and the Docker host, and use the host’s networking directly.\nNO PORT MAPPING REQUIRED!\n If you use the host network mode for a container, that container’s network stack is not isolated from the Docker host (the container shares the host’s networking namespace), and the container does not get its own IP-address allocated. For instance, if you run a container which binds to port 80 and you use host networking, the container’s application is available on port 80 on the host’s IP address.\n  Use host networks - Docker Docs  for the container running using the host network, any port mapping option will be ignored.\nNone Network  For this container, disable all networking. Usually used in conjunction with a custom network driver.\nThis container will be isolated from any network, it cannot contact with any other machine, or container. It’s like the container is in quarantine alone!\nOverlay Network   Overlay networks connect multiple Docker daemons together and enable swarm services to communicate with each other. You can also use overlay networks to facilitate communication between a swarm service and a standalone container, or between two standalone containers on different Docker daemons. This strategy removes the need to do OS-level routing between these containers. See overlay networks.\n  Networking Overview - Docker Docs  Macvlan Network   Macvlan networks allow you to assign a MAC address to a container, making it appear as a physical device on your network. The Docker daemon routes traffic to containers by their MAC addresses. Using the Macvlan driver is sometimes the best choice when dealing with legacy applications that expect to be directly connected to the physical network, rather than routed through the Docker host’s network stack. See Macvlan networks.\n  Networking Overview - Docker Docs    Docker Networks Management\nList all Networks docker network lsLists all the networks along side with there names, ids, drivers, and scope.\nCreate new Network docker network create $network_name -d $driverCreates a new network with the specified unique name, the default network driver is bridge\nRemove a Network docker network rm $network_idRemove all Networks docker network pruneGet Network Info - Inspect docker network inspect $network_name Gives you a JSON file contains all sort of info about the network, containing the IP address and the Gate-way IP address\nConnect a network to a running container docker network connect $network_id $container_idDis-Connect a network to a running container docker network disconnect $network_id $container_id  Attach a Container to a Network\nWhen running the Container docker run --network=$network_name $image_name# for exampledocker create webappNetwork -d bridgedocker run -td --network=webappNetwork a7medaymamn6/hello-worldNow get the IP address of the network you created\ndocker network inspect web | grep \"IPv4\" | cut -d \":\" -f 2 | cut -d \"\\\"\" -f 2 | cut -d \"/\" -f 1# 172.18.0.2this will get you the IP address after cutting out the label, the column ‘:', the double-quotes ' \" ‘, and finally cutting out the net-mask\nyou can visit this IP with the suffix :5000 adding the port that the web-app working on the browser, and wallah! the website is there!\n  Communicate Between two Containers in the same network\nLet’s try the thing out, we’ll run two containers and ping each other using their names and IPs We’ll use the alpine image which have ping installed by default and it’s light\n  # create a new network docker network create connect-containers # - 77dcad281962e75132a0aa83028bfa6d632cc09a19d76246d2e68c299c879796 # create the first container docker run --rm -it --network=connect-containers --name=cont1 alpine # - now we have a shell back ! ping cont2 # - PING cont1 (172.18.0.2): 56 data bytes # - 64 bytes from 172.18.0.2: seq=0 ttl=64 time=0.292 ms # - 64 bytes from 172.18.0.2: seq=1 ttl=64 time=0.167 ms # - 64 bytes from 172.18.0.2: seq=2 ttl=64 time=0.175 ms ^C # it's sending the packets which means cont2 is app and running # let's try to do the same with the ip address # get the ip address ifconfig | grep inet # - inet addr:172.18.0.3 Bcast:172.18.255.255 Mask:255.255.0.0 # - inet addr:127.0.0.1 Mask:255.0.0.0 # 172.18.0.3 this is cont2 (this shell session) ip address # and 172.18.0.3 is cont1 ip address ping 172.18.0.2 # - PING 172.18.0.2 (172.18.0.2): 56 data bytes # - 64 bytes from 172.18.0.2: seq=0 ttl=64 time=0.292 ms # - 64 bytes from 172.18.0.2: seq=1 ttl=64 time=0.167 ms # - 64 bytes from 172.18.0.2: seq=2 ttl=64 time=0.175 ms ^C # it's sending the packets which means cont2 is app and running # create the second container docker run --rm -it --network=connect-containers --name=cont1 alpine # - now we have a shell back ! ping cont1 # - PING cont1 (172.18.0.3): 56 data bytes # - 64 bytes from 172.18.0.3: seq=0 ttl=64 time=0.292 ms # - 64 bytes from 172.18.0.3: seq=1 ttl=64 time=0.167 ms # - 64 bytes from 172.18.0.3: seq=2 ttl=64 time=0.175 ms ^C # it's sending the packets which means cont1 is app and running # let's try to do the same with the ip address # get the ip address ifconfig | grep inet # - inet addr:172.18.0.2 Bcast:172.18.255.255 Mask:255.255.0.0 # - inet addr:127.0.0.1 Mask:255.0.0.0 # 172.18.0.2 this is cont2 (this shell session) ip address # and 172.18.0.3 is cont1 ip address ping 172.18.0.3 # - PING 172.18.0.3 (172.18.0.3): 56 data bytes # - 64 bytes from 172.18.0.3: seq=0 ttl=64 time=0.292 ms # - 64 bytes from 172.18.0.3: seq=1 ttl=64 time=0.167 ms # - 64 bytes from 172.18.0.3: seq=2 ttl=64 time=0.175 ms ^C # it's sending the packets which means 172.18.0.3 is app and running CMD vs Entry-points   CMD\nONLY ONE CMD COMMAND\nActually I lied, you can have more than one CMD command, but only the last one will get executed!\nSets defaults for running a container\nit tells the engine exactly how to run a container from this image if no commands are specified ( if any commands were specified it will overwrite the CMD command )\nCMD [\"python3\", \"app.py\"]# ORCMD python3 app.py  NOTE : A CMD command in the docker run command will override the default in the Dockerfile.\ndocker run --rm -it ubuntu ls# bin dev home lib32\tlibx32\tmnt proc run\tsrv tmp var# boot etc lib\tlib64\tmedia\topt root sbin sys usr# ______________________________________________________# so the ls command will override the CMD command that written in ubuntu dockerfile which is /bin/bash# so actually when you run this command you will get the output of ls command and you will not get a shell! # the ls process gets executed then the container exits    Entry-Point\nIn the Dockerfile you can use the entry point to do the same job as CMD, to set the executable that runs whenever the container runs.\nENTRYPOINT python3 app.py So what happens when we have an entry point AND a CMD command ?!\nin this situation CMD acts as an extension for the command in the ENTRYPOINT, it gets appended to it! it’s like the actual command is the concatenation of ENTRYPOINT_VALUE + CMD_VALUES\nLet’s try it out, we’ll setup a little image based on Ubuntu\n# build an image on the top of ubuntu imageFROMubuntu# exectue the command ls once the container gets runENTRYPOINT ls# append to the ENTRYPOINT command the -a argument CMD -a# now the command that will get exectued is ls -aWe know that the extra command when executing the run command overwrites the CMD command so what happens when we have an Entry-point like the above example? let’s se\ndocker build -t demo -f Dockerfiledocker run demo -lactually this well overwrite the -a and executes ls -l command!\nIn the end it’s okay to use either or both, most of the times you can get-away with CMD only.\n  Multi-Stage Docker Builds ( MSDB )   What is MSDB ?\n MSDB allow you to extract artifacts from docker image builds, leaving behind all the extra junk you don’t need.\n  Mastermnd    Multiple FROM Commands\nRemember when I said you can only have one FROM command in your Dockerfile ? guess what ! I lied again, get used to it!\nEach new FROM command initiates a new stage of the build\nYou can name the stage using the AS keyword in the FROM command\nWhy would you do that ? good question, so here is how the MSDB works, first it builds the first stage complete it, then REMOVES THE INTERMEDIATE CONTAINER after that docker starts to build the next stage without the earlier stage! think about it, let’s say you’re dockeraizing a C/C++ application for example based on Ubuntu image, the docker file instructions will be smth like this\nFROMubuntu AS compile-stepRUN apt update RUN mkdir /buildWORKDIR/buildCOPY prog.c .RUN gcc -o prog.o prog.cCMD ./prog.oRead the above Dockerfile thoroughly and think about it!\nwhat do you really need from this container ?\n to compile and build the program to run the program  so we don’t need all the size that comes with the Ubuntu image, we can use it as an intermediate container to compile and build the program, then copy the .o (binary) file into a new fresh container with a smaller size just enough to run the binary executable file!\nhere is what our Dockerfile should look like\n# Stage 1 - compile and build the c program using gcc based on Ubuntu imageFROMubuntu AS compile-stepRUN apt update RUN mkdir /buildWORKDIR/buildCOPY prog.c .RUN gcc -o prog.o prog.c# Stage 2 - run the executable file based on alpine image which is a very small size imageFROMalpine AS run-stepRUN mkdir /appWORKDIR/app# copy the binary file from the previous stageCOPY --from=compile-step /build/prog.o .CMD ./prog.oNOTE : IN THIS EXAMPLE WE COULD USE ALPINE DIRECTLY BUT WE DID THIS FOR THE SAKE OF DEMONSTRATION, BUT TRY TO THINK BIGGER AND MORE COMPLEX SITUATIONS!\nNow the actual size of the image will drop down a lot!\nalpine image is a very small image with size of 5.61 MB only, and the Ubuntu:latest image size is 72.7 MB\nSo the big catch here is reducing the size of the image by extracting only what we need into a lighter base image and using the first one to make a certain job then throw it away!\n  ","wordCount":"1985","inLanguage":"en","datePublished":"2021-07-28T01:16:57+02:00","dateModified":"2021-07-28T01:16:57+02:00","author":{"@type":"Person","name":"Ahmed Ayman"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://a7medayman6.github.io/blog/devops/diving-with-the-whale-docker-series/day-iv/"},"publisher":{"@type":"Organization","name":"Ahmed Ayman","logo":{"@type":"ImageObject","url":"https://a7medayman6.github.io/%3Clink%20/%20abs%20url%3E"}}}</script></head><body class=dark id=top><script>if(localStorage.getItem("pref-theme")==="light"){document.body.classList.remove('dark')}</script><noscript><style type=text/css>#theme-toggle,.top-link{display:none}</style></noscript><header class=header><nav class=nav><div class=logo><a href=https://a7medayman6.github.io/ accesskey=h title="Ahmed Ayman (Alt + H)">Ahmed Ayman</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://a7medayman6.github.io/about/ title=About><span>About</span></a></li><li><a href=https://a7medayman6.github.io/projects/ title=Projects><span>Projects</span></a></li><li><a href=https://a7medayman6.github.io/blog/ title=Blog><span>Blog</span></a></li><li><a href=https://a7medayman6.github.io/thoughts/ title=Thoughts><span>Thoughts</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://a7medayman6.github.io/>Home</a></div><h1 class=post-title>Docker Networking, Entry Points, and more.</h1><div class=post-meta>July 28, 2021&nbsp;·&nbsp;10 min&nbsp;·&nbsp;Ahmed Ayman</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><div class=details>Table of Contents</div></summary><div class=inner><ul><li><a href=#diving-with-the-whale---docker--day-iv---docker-networking-entry-points-and-more aria-label="Diving with the Whale - Docker  Day IV - Docker Networking, Entry Points, and more.">Diving with the Whale - Docker Day IV - Docker Networking, Entry Points, and more.</a></li><li><a href=#docker-networking aria-label="Docker Networking">Docker Networking</a><ul><ul><li><a href=#list-all-networks aria-label="List all Networks">List all Networks</a></li><li><a href=#create-new-network aria-label="Create new Network">Create new Network</a></li><li><a href=#remove-a-network aria-label="Remove a Network">Remove a Network</a></li><li><a href=#remove-all-networks aria-label="Remove all Networks">Remove all Networks</a></li><li><a href=#get-network-info---inspect aria-label="Get Network Info - Inspect">Get Network Info - Inspect</a></li><li><a href=#connect-a-network-to-a-running-container aria-label="Connect a network to a running container">Connect a network to a running container</a></li><li><a href=#dis-connect-a-network-to-a-running-container aria-label="Dis-Connect a network to a running container">Dis-Connect a network to a running container</a></li><li><a href=#when-running-the-container aria-label="When running the Container">When running the Container</a></li></ul></ul></li><li><a href=#cmd-vs-entry-points aria-label="CMD vs Entry-points">CMD vs Entry-points</a></li><li><a href=#multi-stage-docker-builds--msdb- aria-label="Multi-Stage Docker Builds ( MSDB )">Multi-Stage Docker Builds ( MSDB )</a></li></ul></div></details></div><div class=post-content><h1 id=diving-with-the-whale---docker--day-iv---docker-networking-entry-points-and-more>Diving with the Whale - Docker Day IV - Docker Networking, Entry Points, and more.<a hidden class=anchor aria-hidden=true href=#diving-with-the-whale---docker--day-iv---docker-networking-entry-points-and-more>#</a></h1><h1 id=docker-networking>Docker Networking<a hidden class=anchor aria-hidden=true href=#docker-networking>#</a></h1><p><strong>How can we let two or more containers talking to each other ? through docker containers!</strong></p><p>Networking in containers is controlling who can talk to who including all the running containers, and the local-host.</p><ul><li><p><strong>Docker Network Drivers</strong></p><p>Several drivers exist by default in docker, and provide core networking functionality</p><ol><li><p><strong>Bridge Network</strong></p><p><strong>The default network driver. If you don’t specify a driver, this is the type of network you are creating. Bridge networks are usually used when your applications run in standalone containers that need to communicate.</strong></p><p>you can also create your own user-defined bridge network and connect multiple container to it so they can contact with each other! - we&rsquo;ll see how in the next section -</p><blockquote><p>A network bridge is a computer networking hardware device or a software device running within a host machine’s kernel. that creates a single, aggregate network from multiple communication networks or network segments. This function is called network bridging. Bridging is distinct from routing. Routing allows multiple networks to communicate independently and yet remain separate, whereas bridging connects two separate networks as if they were a single network. In the OSI model, bridging is performed in the data link layer (layer 2). If one or more segments of the bridged network are wireless, the device is known as a wireless bridge.</p></blockquote><ul><li><a href=https://en.wikipedia.org/wiki/Bridging_(networking)>Bridging (networking) - Wikipedia</a></li></ul><blockquote><p>In terms of Docker, a bridge network uses a software bridge which allows containers connected to the same bridge network to communicate, while providing isolation from containers which are not connected to that bridge network. The Docker bridge driver automatically installs rules in the host machine so that containers on different bridge networks cannot communicate directly with each other.</p></blockquote><ul><li><a href=https://docs.docker.com/network/bridge/>Use bridge networks - Docker Docs</a></li></ul></li></ol><p><img loading=lazy src=/blog/devops/docker-series/day-4/3153ae0fc24952bc0bf5d1154595f21b.gif#center alt=Diving%20with%20the%20Whale%20-%20Docker%20Day%20IV%20-%20Docker%20Net%206f9217d5dfa147669d058555a1963ccf/3153ae0fc24952bc0bf5d1154595f21b.gif></p><ol start=2><li><strong>Host Network</strong></li></ol><p><strong>For standalone containers, remove network isolation between the container and the Docker host, and use the host’s networking directly.</strong></p><p><strong>NO PORT MAPPING REQUIRED!</strong></p><blockquote><p>If you use the host network mode for a container, that container’s network stack is not isolated from the Docker host (the container shares the host’s networking namespace), and the container does not get its own IP-address allocated. For instance, if you run a container which binds to port 80 and you use host networking, the container’s application is available on port 80 on the host’s IP address.</p></blockquote><ul><li><a href=https://docs.docker.com/network/host/>Use host networks - Docker Docs</a></li></ul><p>for the container running using the host network, any port mapping option will be ignored.</p><ol start=3><li><strong>None Network</strong></li></ol><p><strong>For this container, disable all networking. Usually used in conjunction with a custom network driver.</strong></p><p>This container will be isolated from any network, it cannot contact with any other machine, or container. It&rsquo;s like the container is in quarantine alone!</p><p><img loading=lazy src=/blog/devops/docker-series/day-4/Untitled.png alt=Diving%20with%20the%20Whale%20-%20Docker%20Day%20IV%20-%20Docker%20Net%206f9217d5dfa147669d058555a1963ccf/Untitled.png></p><ol start=4><li><strong>Overlay Network</strong></li></ol><blockquote><p>Overlay networks connect multiple Docker daemons together and enable swarm services to communicate with each other. You can also use overlay networks to facilitate communication between a swarm service and a standalone container, or between two standalone containers on different Docker daemons. This strategy removes the need to do OS-level routing between these containers. See overlay networks.</p></blockquote><ul><li><a href=https://docs.docker.com/network/>Networking Overview - Docker Docs</a></li></ul><ol start=5><li><strong>Macvlan Network</strong></li></ol><blockquote><p>Macvlan networks allow you to assign a MAC address to a container, making it appear as a physical device on your network. The Docker daemon routes traffic to containers by their MAC addresses. Using the Macvlan driver is sometimes the best choice when dealing with legacy applications that expect to be directly connected to the physical network, rather than routed through the Docker host’s network stack. See <a href=https://docs.docker.com/network/macvlan/>Macvlan networks</a>.</p></blockquote><ul><li><a href=https://docs.docker.com/network/>Networking Overview - Docker Docs</a></li></ul></li><li><p><strong>Docker Networks Management</strong></p><h3 id=list-all-networks>List all Networks<a hidden class=anchor aria-hidden=true href=#list-all-networks>#</a></h3><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-docker data-lang=docker>docker network ls<span style=color:#960050;background-color:#1e0010>
</span></code></pre></div><p>Lists all the networks along side with there names, ids, drivers, and scope.</p><h3 id=create-new-network>Create new Network<a hidden class=anchor aria-hidden=true href=#create-new-network>#</a></h3><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-docker data-lang=docker>docker network create $network_name -d $driver<span style=color:#960050;background-color:#1e0010>
</span></code></pre></div><p>Creates a new network with the specified unique name, the default network driver is <strong>bridge</strong></p><h3 id=remove-a-network>Remove a Network<a hidden class=anchor aria-hidden=true href=#remove-a-network>#</a></h3><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-docker data-lang=docker>docker network rm $network_id<span style=color:#960050;background-color:#1e0010>
</span></code></pre></div><h3 id=remove-all-networks>Remove all Networks<a hidden class=anchor aria-hidden=true href=#remove-all-networks>#</a></h3><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-docker data-lang=docker>docker network prune<span style=color:#960050;background-color:#1e0010>
</span></code></pre></div><h3 id=get-network-info---inspect>Get Network Info - Inspect<a hidden class=anchor aria-hidden=true href=#get-network-info---inspect>#</a></h3><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-docker data-lang=docker>docker network inspect $network_name <span style=color:#960050;background-color:#1e0010>
</span></code></pre></div><p>Gives you a JSON file contains all sort of info about the network, containing the IP address and the Gate-way IP address</p><h3 id=connect-a-network-to-a-running-container>Connect a network to a running container<a hidden class=anchor aria-hidden=true href=#connect-a-network-to-a-running-container>#</a></h3><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-docker data-lang=docker>docker network connect $network_id $container_id<span style=color:#960050;background-color:#1e0010>
</span></code></pre></div><h3 id=dis-connect-a-network-to-a-running-container>Dis-Connect a network to a running container<a hidden class=anchor aria-hidden=true href=#dis-connect-a-network-to-a-running-container>#</a></h3><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-docker data-lang=docker>docker network disconnect $network_id $container_id<span style=color:#960050;background-color:#1e0010>
</span></code></pre></div></li><li><p><strong>Attach a Container to a Network</strong></p><h3 id=when-running-the-container>When running the Container<a hidden class=anchor aria-hidden=true href=#when-running-the-container>#</a></h3><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-docker data-lang=docker>docker run --network<span style=color:#f92672>=</span>$network_name $image_name<span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#75715e># for example</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span>docker create webappNetwork -d bridge<span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span>docker run -td --network<span style=color:#f92672>=</span>webappNetwork a7medaymamn6/hello-world<span style=color:#960050;background-color:#1e0010>
</span></code></pre></div><p>Now get the IP address of the network you created</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-docker data-lang=docker>docker network inspect web | grep <span style=color:#e6db74>&#34;IPv4&#34;</span> | cut -d <span style=color:#e6db74>&#34;:&#34;</span> -f <span style=color:#ae81ff>2</span> | cut -d <span style=color:#e6db74>&#34;\&#34;&#34;</span>  -f <span style=color:#ae81ff>2</span> | cut -d <span style=color:#e6db74>&#34;/&#34;</span> -f <span style=color:#ae81ff>1</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#75715e># 172.18.0.2</span><span style=color:#960050;background-color:#1e0010>
</span></code></pre></div><p>this will get you the IP address after cutting out the label, the column &lsquo;:', the double-quotes ' " &lsquo;, and finally cutting out the net-mask</p><p>you can visit this IP with the suffix :5000 adding the port that the web-app working on the browser, and wallah! the website is there!</p></li><li><p><strong>Communicate Between two Containers in the same network</strong></p><p>Let&rsquo;s try the thing out, we&rsquo;ll run two containers and ping each other using their names and IPs
We&rsquo;ll use the alpine image which have ping installed by default and it&rsquo;s light</p></li></ul><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#75715e># create a new network</span>
docker network create connect-containers 
<span style=color:#75715e># - 77dcad281962e75132a0aa83028bfa6d632cc09a19d76246d2e68c299c879796</span> 

<span style=color:#75715e># create the first container</span>
docker run --rm -it --network<span style=color:#f92672>=</span>connect-containers --name<span style=color:#f92672>=</span>cont1 alpine
<span style=color:#75715e># - now we have a shell back !</span> 
ping cont2  
<span style=color:#75715e># - PING cont1 (172.18.0.2): 56 data bytes</span>
<span style=color:#75715e># - 64 bytes from 172.18.0.2: seq=0 ttl=64 time=0.292 ms</span>
<span style=color:#75715e># - 64 bytes from 172.18.0.2: seq=1 ttl=64 time=0.167 ms</span>
<span style=color:#75715e># - 64 bytes from 172.18.0.2: seq=2 ttl=64 time=0.175 ms</span>
^C
<span style=color:#75715e># it&#39;s sending the packets which means cont2 is app and running</span>

<span style=color:#75715e># let&#39;s try to do the same with the ip address</span> 
<span style=color:#75715e># get the ip address</span> 
ifconfig | grep inet
<span style=color:#75715e># - inet addr:172.18.0.3  Bcast:172.18.255.255  Mask:255.255.0.0</span>
<span style=color:#75715e># - inet addr:127.0.0.1  Mask:255.0.0.0</span>
<span style=color:#75715e># 172.18.0.3 this is cont2 (this shell session) ip address</span>
<span style=color:#75715e># and 172.18.0.3 is cont1 ip address</span>
ping 172.18.0.2
<span style=color:#75715e># - PING 172.18.0.2 (172.18.0.2): 56 data bytes</span>
<span style=color:#75715e># - 64 bytes from 172.18.0.2: seq=0 ttl=64 time=0.292 ms</span>
<span style=color:#75715e># - 64 bytes from 172.18.0.2: seq=1 ttl=64 time=0.167 ms</span>
<span style=color:#75715e># - 64 bytes from 172.18.0.2: seq=2 ttl=64 time=0.175 ms</span>
^C
<span style=color:#75715e># it&#39;s sending the packets which means cont2 is app and running</span>
</code></pre></div><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#75715e># create the second container</span> 
docker run --rm -it --network<span style=color:#f92672>=</span>connect-containers --name<span style=color:#f92672>=</span>cont1 alpine
<span style=color:#75715e># - now we have a shell back !</span> 
ping cont1  
<span style=color:#75715e># - PING cont1 (172.18.0.3): 56 data bytes</span>
<span style=color:#75715e># - 64 bytes from 172.18.0.3: seq=0 ttl=64 time=0.292 ms</span>
<span style=color:#75715e># - 64 bytes from 172.18.0.3: seq=1 ttl=64 time=0.167 ms</span>
<span style=color:#75715e># - 64 bytes from 172.18.0.3: seq=2 ttl=64 time=0.175 ms</span>
^C
<span style=color:#75715e># it&#39;s sending the packets which means cont1 is app and running</span>

<span style=color:#75715e># let&#39;s try to do the same with the ip address</span> 
<span style=color:#75715e># get the ip address</span> 
ifconfig | grep inet
<span style=color:#75715e># - inet addr:172.18.0.2  Bcast:172.18.255.255  Mask:255.255.0.0</span>
<span style=color:#75715e># - inet addr:127.0.0.1  Mask:255.0.0.0</span>
<span style=color:#75715e># 172.18.0.2 this is cont2 (this shell session) ip address</span>
<span style=color:#75715e># and 172.18.0.3 is cont1 ip address</span>
ping 172.18.0.3
<span style=color:#75715e># - PING 172.18.0.3 (172.18.0.3): 56 data bytes</span>
<span style=color:#75715e># - 64 bytes from 172.18.0.3: seq=0 ttl=64 time=0.292 ms</span>
<span style=color:#75715e># - 64 bytes from 172.18.0.3: seq=1 ttl=64 time=0.167 ms</span>
<span style=color:#75715e># - 64 bytes from 172.18.0.3: seq=2 ttl=64 time=0.175 ms</span>
^C
<span style=color:#75715e># it&#39;s sending the packets which means 172.18.0.3 is app and running</span>

</code></pre></div><h1 id=cmd-vs-entry-points>CMD vs Entry-points<a hidden class=anchor aria-hidden=true href=#cmd-vs-entry-points>#</a></h1><ul><li><p><strong>CMD</strong></p><p><strong>ONLY ONE CMD COMMAND</strong></p><p>Actually I lied, you can have more than one CMD command, but only the last one will get executed!</p><p>Sets defaults for running a container</p><p>it tells the engine exactly how to run a container from this image if no commands are specified ( if any commands were specified it will overwrite the CMD command )</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-docker data-lang=docker><span style=color:#66d9ef>CMD</span> [<span style=color:#e6db74>&#34;python3&#34;</span>, <span style=color:#e6db74>&#34;app.py&#34;</span>]<span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#75715e># OR</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>CMD</span> python3 app.py<span style=color:#960050;background-color:#1e0010>
</span></code></pre></div><ul><li><p>NOTE : A CMD command in the docker run command will override the default in the Dockerfile.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-docker data-lang=docker>docker run --rm -it ubuntu ls<span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#75715e># bin   dev  home  lib32	libx32	mnt  proc  run	 srv  tmp  var</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#75715e># boot  etc  lib	 lib64	media	opt  root  sbin  sys  usr</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#75715e># ______________________________________________________</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#75715e># so the ls command will override the CMD command that written in ubuntu dockerfile which is /bin/bash</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#75715e># so actually when you run this command you will get the output of ls command and you will not get a shell! </span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#75715e># the ls process gets executed then the container exits</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010>
</span></code></pre></div></li></ul></li><li><p><strong>Entry-Point</strong></p><p>In the Dockerfile you can use the entry point to do the same job as CMD, to set the executable that runs whenever the container runs.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-docker data-lang=docker><span style=color:#66d9ef>ENTRYPOINT</span> python3 app.py <span style=color:#960050;background-color:#1e0010>
</span></code></pre></div><p>So what happens when we have an entry point AND a CMD command ?!</p><p>in this situation CMD acts as an extension for the command in the ENTRYPOINT, it gets appended to it!
it&rsquo;s like the actual command is the concatenation of ENTRYPOINT_VALUE + CMD_VALUES</p><p>Let&rsquo;s try it out, we&rsquo;ll setup a little image based on Ubuntu</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-docker data-lang=docker><span style=color:#75715e># build an image on the top of ubuntu image</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>FROM</span><span style=color:#e6db74> ubuntu</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#75715e># exectue the command ls once the container gets run</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>ENTRYPOINT</span> ls<span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#75715e># append to the ENTRYPOINT command the -a argument </span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>CMD</span> -a<span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#75715e># now the command that will get exectued is ls -a</span><span style=color:#960050;background-color:#1e0010>
</span></code></pre></div><p>We know that the extra command when executing the run command overwrites the CMD command
so what happens when we have an Entry-point like the above example? let&rsquo;s se</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-docker data-lang=docker>docker build -t demo -f Dockerfile<span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span>docker run demo -l<span style=color:#960050;background-color:#1e0010>
</span></code></pre></div><p>actually this well overwrite the -a and executes ls -l command!</p><p>In the end it&rsquo;s okay to use either or both, most of the times you can get-away with CMD only.</p></li></ul><h1 id=multi-stage-docker-builds--msdb->Multi-Stage Docker Builds ( MSDB )<a hidden class=anchor aria-hidden=true href=#multi-stage-docker-builds--msdb->#</a></h1><ul><li><p><strong>What is MSDB ?</strong></p><blockquote><p>MSDB allow you to extract artifacts from docker image builds, leaving behind all the extra junk you don’t need.</p></blockquote><ul><li><a href=https://academy.mastermnd.io/>Mastermnd</a></li></ul></li><li><p><strong>Multiple FROM Commands</strong></p><p>Remember when I said you can only have one FROM command in your Dockerfile ? guess what ! I lied again, get used to it!</p><p><strong>Each new FROM command initiates a new stage of the build</strong></p><p><strong>You can name the stage using the AS keyword in the FROM command</strong></p><p>Why would you do that ?
good question, so here is how the MSDB works, first it builds the first stage complete it, then <strong>REMOVES THE INTERMEDIATE CONTAINER</strong> after that docker starts to build the next stage without the earlier stage!
think about it, let&rsquo;s say you&rsquo;re dockeraizing a C/C++ application for example based on Ubuntu image, the docker file instructions will be smth like this</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-docker data-lang=docker><span style=color:#66d9ef>FROM</span><span style=color:#e6db74> ubuntu AS compile-step</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>RUN</span> apt update <span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>RUN</span> mkdir /build<span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>WORKDIR</span><span style=color:#e6db74> /build</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>COPY</span> prog.c .<span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>RUN</span> gcc -o prog.o prog.c<span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>CMD</span> ./prog.o<span style=color:#960050;background-color:#1e0010>
</span></code></pre></div><p>Read the above Dockerfile thoroughly and think about it!</p><p>what do you really need from this container ?</p><ol><li>to compile and build the program</li><li>to run the program</li></ol><p>so we don&rsquo;t need all the size that comes with the Ubuntu image, we can use it as an intermediate container to compile and build the program, then copy the .o (binary) file into a new fresh container with a smaller size just enough to run the binary executable file!</p><p>here is what our Dockerfile should look like</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-docker data-lang=docker><span style=color:#75715e># Stage 1 - compile and build the c program using gcc based on Ubuntu image</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>FROM</span><span style=color:#e6db74> ubuntu AS compile-step</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>RUN</span> apt update <span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>RUN</span> mkdir /build<span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>WORKDIR</span><span style=color:#e6db74> /build</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>COPY</span> prog.c .<span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>RUN</span> gcc -o prog.o prog.c<span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#75715e># Stage 2 - run the executable file based on alpine image which is a very small size image</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>FROM</span><span style=color:#e6db74> alpine AS run-step</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>RUN</span> mkdir /app<span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>WORKDIR</span><span style=color:#e6db74> /app</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#75715e># copy the binary file from the previous stage</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>COPY</span> --from<span style=color:#f92672>=</span>compile-step /build/prog.o .<span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>CMD</span> ./prog.o<span style=color:#960050;background-color:#1e0010>
</span></code></pre></div><p>NOTE : IN THIS EXAMPLE WE COULD USE ALPINE DIRECTLY BUT WE DID THIS FOR THE SAKE OF DEMONSTRATION, BUT TRY TO THINK BIGGER AND MORE COMPLEX SITUATIONS!</p><p>Now the actual size of the image will drop down a lot!</p><p>alpine image is a very small image with size of 5.61 MB only, and the Ubuntu:latest image size is 72.7 MB</p><p>So the big catch here is reducing the size of the image by extracting only what we need into a lighter base image and using the first one to make a certain job then throw it away!</p></li></ul></div><footer class=post-footer><nav class=paginav><a class=prev href=https://a7medayman6.github.io/blog/devops/intro-to-devops/><span class=title>« Prev Page</span><br><span>Introduction To DevOps</span></a>
<a class=next href=https://a7medayman6.github.io/blog/devops/devops-lifecycle/><span class=title>Next Page »</span><br><span>Devops Lifecycle</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share Docker Networking, Entry Points, and more. on twitter" href="https://twitter.com/intent/tweet/?text=Docker%20Networking%2c%20Entry%20Points%2c%20and%20more.&url=https%3a%2f%2fa7medayman6.github.io%2fblog%2fdevops%2fdiving-with-the-whale-docker-series%2fday-iv%2f&hashtags="><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512h-386.892c-34.524.0-62.554-28.03-62.554-62.554v-386.892c0-34.524 28.029-62.554 62.554-62.554h386.892zm-253.927 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z" /></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Docker Networking, Entry Points, and more. on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fa7medayman6.github.io%2fblog%2fdevops%2fdiving-with-the-whale-docker-series%2fday-iv%2f&title=Docker%20Networking%2c%20Entry%20Points%2c%20and%20more.&summary=Docker%20Networking%2c%20Entry%20Points%2c%20and%20more.&source=https%3a%2f%2fa7medayman6.github.io%2fblog%2fdevops%2fdiving-with-the-whale-docker-series%2fday-iv%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512h-386.892c-34.524.0-62.554-28.03-62.554-62.554v-386.892c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0v-129.439c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02v-126.056c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768h75.024zm-307.552-334.556c-25.674.0-42.448 16.879-42.448 39.002.0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z" /></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Docker Networking, Entry Points, and more. on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fa7medayman6.github.io%2fblog%2fdevops%2fdiving-with-the-whale-docker-series%2fday-iv%2f&title=Docker%20Networking%2c%20Entry%20Points%2c%20and%20more."><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512h-386.892c-34.524.0-62.554-28.03-62.554-62.554v-386.892c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zm-119.474 108.193c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zm-160.386-29.702c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z" /></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Docker Networking, Entry Points, and more. on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fa7medayman6.github.io%2fblog%2fdevops%2fdiving-with-the-whale-docker-series%2fday-iv%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978v-192.915h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554v-386.892c0-34.524 28.029-62.554 62.554-62.554h386.892z" /></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Docker Networking, Entry Points, and more. on whatsapp" href="https://api.whatsapp.com/send?text=Docker%20Networking%2c%20Entry%20Points%2c%20and%20more.%20-%20https%3a%2f%2fa7medayman6.github.io%2fblog%2fdevops%2fdiving-with-the-whale-docker-series%2fday-iv%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512h-386.892c-34.524.0-62.554-28.03-62.554-62.554v-386.892c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23-13.314-11.876-22.304-26.542-24.916-31.026s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z" /></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Docker Networking, Entry Points, and more. on telegram" href="https://telegram.me/share/url?text=Docker%20Networking%2c%20Entry%20Points%2c%20and%20more.&url=https%3a%2f%2fa7medayman6.github.io%2fblog%2fdevops%2fdiving-with-the-whale-docker-series%2fday-iv%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47A3.38 3.38.0 0126.49 29.86zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z" /></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2021 <a href=https://a7medayman6.github.io/>Ahmed Ayman</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)"><button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z" /></svg></button></a>
<script>let menu=document.getElementById('menu')
menu.scrollLeft=localStorage.getItem("menu-scroll-position");menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft);}
document.querySelectorAll('a[href^="#"]').forEach(anchor=>{anchor.addEventListener("click",function(e){e.preventDefault();var id=this.getAttribute("href").substr(1);if(!window.matchMedia('(prefers-reduced-motion: reduce)').matches){document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({behavior:"smooth"});}else{document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();}
if(id==="top"){history.replaceState(null,null," ");}else{history.pushState(null,null,`#${id}`);}});});</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){if(document.body.scrollTop>800||document.documentElement.scrollTop>800){mybutton.style.visibility="visible";mybutton.style.opacity="1";}else{mybutton.style.visibility="hidden";mybutton.style.opacity="0";}};</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{if(document.body.className.includes("dark")){document.body.classList.remove('dark');localStorage.setItem("pref-theme",'light');}else{document.body.classList.add('dark');localStorage.setItem("pref-theme",'dark');}})</script></body></html>